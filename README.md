# View Types

[![Maven Central](https://img.shields.io/maven-central/v/ru.noties/vt.svg)](http://search.maven.org/#search\|ga\|1\|g%3A%22ru.noties%22%20AND%20a%3A%22vt%22)

Abstraction to build adapters with dynamic/variable view types count for Android application. It eliminates the need to manually define view types (via Enum<?>, or if you follow Google Developers advice integer constants (less memory usage, you know!)). Makes code readable and actually share view types across multiple screens (no need to write a new adapter, or add view types handling in one base adapter with endless switch statement).

Please note, RecyclerView only.


## Installation
Add a dependency into your build.gradle:
```gradle
compile `ru.noties:vt:1.0.0`
```
If you don't have RecyclerView dependency in your project already, you must add it also:
```gradle
// at the time of writing the latest version is '25.0.0'
// theoretically it should work with older versions as well, but I haven't tested it
compile `com.android.support:recyclerview-v7:25.0.0`
```

## Usage

```java
final ViewTypesAdapter<One> adapter = ViewTypesAdapter.builder(One.class)
        .register(One.class, new ViewTypeOne(), null) // will be not clickable
        .register(Two.class, new ViewTypeTwo(), new OnItemClickListener<Two, HolderSingle<TextView>>() {
            @Override
            public void onItemClick(Two item, HolderSingle<TextView> holder) {

            }
        })
        .register(Three.class, new ViewTypeOne())
        .setHasStableIds(true)
 //       .registerOnDataSetChangedListener(new DiffUtilDataSetChanged<One>(true))
        .registerOnDataSetChangedListener(new NotifyDataSetChanged<One>())
        .registerOnClickListener(new OnItemClickListener<One, Holder>() {
            @Override
            public void onItemClick(One item, Holder holder) {
                Debug.i("class: `%s`, value: %s", item.getClass().getSimpleName(), item.oneValue);
            }
        })
        .build(this); // context
```

### ru.noties.vt.ViewType
The core class of this library is `ru.noties.vt.ViewType<T, H extends Holder>`, where `T` is the type of the item, and `H` a subclass of `ru.noties.vt.Holder` or `ru.noties.vt.Holder` itself if you don't have RecyclerView.ViewHolder specific logic.

```java
public abstract class ViewType<T, H extends Holder> {

    protected abstract H createView(LayoutInflater inflater, ViewGroup parent);
    protected abstract void bindView(Context context, H holder, T item, List<Object> payloads);

    public long itemId(T item) {
        return RecyclerView.NO_ID;
    }
}
```


### ru.noties.vt.Holder

```java
public class Holder extends RecyclerView.ViewHolder {

    public Holder(View itemView) {
        super(itemView);
    }

    public <V extends View> V findView(@IdRes int id) {
        //noinspection unchecked
        return (V) itemView.findViewById(id);
    }
}
```
Has one utility method to automatically cast view. For example:
```java
final TextView text = findView(R.id.text);
```

There is also `HolderSingle` if Holder holds exactly one view.
```java
public class HolderSingle<V extends View> extends Holder {

    public final V view;

    public HolderSingle(View itemView) {
        super(itemView);
        //noinspection unchecked
        view = (V) itemView;
    }

    public HolderSingle(View itemView, @IdRes int id) {
        super(itemView);
        view = findView(id);
    }
}
```
For example:
```java
// automatically cast whole view passed in constructor to TextView
final HolderSingle<TextView> textHolder = new HolderSingle<>(itemView);

// automatically cast view found by id `R.id.image` to ImageView
final HolderSingle<ImageView> imageHolder = new HolderSingle<>(itemView, R.id.image);

// textHolder.view -> TextView
// imageHolder.view -> ImageView
```

### ru.noties.vt.ViewTypesAdapter
Significant methods (without implementation):
```java
public class ViewTypesAdapter<T> extends RecyclerView.Adapter<Holder> {

    // [0]
    public static <T> ViewTypesAdapter.Builder<T> builder(Class<T> base)

    // [1]
    public ViewTypes viewTypes()

    // [2]
    public <ITEM extends T> void setItems(@Nullable List<ITEM> items)

    // [3]
    public <ITEM extends T> void changeItems(List<ITEM> items)

    // [4]
    public List<T> getItems()

    // [5]
    public <ITEM extends T> ITEM getItem(int position)

    // [6]
    public <ITEM extends T> ITEM getItemAs(int position, Class<ITEM> itemClass)
}
```
 * **[0]** - returns `ru.noties.vt.ViewTypesAdapter.Builder` to configure this instance of adapter. Adapter can be created via this builder only.
 * **[1]** - returns `ru.noties.vt.ViewTypes` generated by builder and which posses some important information about current view types (assigned view types, view types count)
 * **[2]** - starts process of updating items that this adapter displays (triggers notification)
 * **[3]** - swaps items without notification must be used by `ru.noties.vt.OnDataSetChangedListener` only
 * **[4]** - returns items that this adapter has (can be null, if no items present)
 * **[5]** - returns and automatically casts item at specified position
 * **[6]** - returns item at specified position and casts it to the specified class parameter



### ru.noties.vt.ViewTypesAdapter.Builder
This class contains all configuration that ViewTypesAdapter need
```java
public static class Builder<T> {
    // constructor
    public Builder(Class<T> base)

    // [0]
    public <VIEW_TYPE_TYPE extends T, ACTUAL_TYPE extends VIEW_TYPE_TYPE, HOLDER extends Holder> Builder<T> register(
        @NonNull Class<ACTUAL_TYPE> itemClass,
        @NonNull ViewType<VIEW_TYPE_TYPE, HOLDER> viewType
    )

    // [1]
    public <VIEW_TYPE_TYPE extends T, ACTUAL_TYPE extends VIEW_TYPE_TYPE, ON_CLICK_TYPE extends T, HOLDER extends Holder> Builder<T> register(
        @NonNull Class<ACTUAL_TYPE> itemClass,
        @NonNull ViewType<VIEW_TYPE_TYPE, HOLDER> viewType,
        @Nullable OnItemClickListener<ON_CLICK_TYPE, HOLDER> click
    )

    // [2]
    public <HOLDER extends Holder> Builder<T> registerOnClickListener(OnItemClickListener<T, HOLDER> click)

    // [3]
    public Builder<T> registerOnDataSetChangedListener(OnDataSetChangedListener<T> onDataSetChangedListener)

    // [4]
    public Builder<T> setHasStableIds(boolean hasStableIds)

    // [5]
    public ViewTypesAdapter<T> build(@NonNull Context context) throws ViewTypesException
}
```
 * **[0]** - registers item with this adapter. The method signature is a bit monstrous, but it gives ability to share `ViewType` across multiple items. For example: `register(String.class, ViewType<String, Holder>)` and `register<String.class, ViewType<CharSequence, Holder>)` are both valid. Please note that even some items can share the same `ViewType` they will be treated as different view types (from adapter perspective)
 * **[1]** - Almost the same as **[0]**, but also adds `OnItemClickListener`. There are two cases: if passed listener is NULL, then this item won't be clickable. If passed listener is NOT NULL then this listener will be triggered event if default listener (from **[2]**) is set
 * **[2]** - Registers default `OnItemClickListener` for all items registered via **[0]** method
 * **[3]** - registers `ru.noties.vt.OnDataSetChangedListener` for this adapter. If this method wasn't called (or called with NULL) the default value of `ru.noties.vt.NotifyDataSetChanged` will be used
 * **[4]** - corresponds with `RecyclerView.Adapter.setHasStableIds` method. When set it's wise to override the `ViewType.itemId()` method
 * **[5]** - executes check for validity of data and returns ready-to-be-used `ViewTypesAdapter`. Throws `ViewTypesException` if this Builder instance was already built and if no items were registered via **[0]** or **[1]** methods


### ru.noties.vt.OnDataSetChangedListener
This is class that evaluates the update logic of new items. It contains one method:
```java
void onDataSetChanged(
        ViewTypesAdapter adapter,
        List<T> oldItems,
        List<T> newItems
);
```
There are 2 implementations of this interface that are bundled with this library: `ru.noties.vt.NotifyDataSetChanged` and `ru.noties.vt.DiffUtilDataSetChanged`. For example, `ru.noties.vt.NotifyDataSetChanged` implementation is as follows:
```java
@Override
public void onDataSetChanged(ViewTypesAdapter adapter, List<T> oldItems, List<T> newItems) {
    // please note that this listener must call `changeItems`, not `setItems`
    adapter.changeItems(newItems);
    adapter.notifyDataSetChanged();
}
```

#### ru.noties.vt.DiffUtilDataSetChanged
`ru.noties.vt.DiffUtilDataSetChanged` is based on `android.support.v7.util.DiffUtil`. It has 4 constructors:
```java
// [0]
public DiffUtilDataSetChanged()

// [1]
public DiffUtilDataSetChanged(boolean detectMoves)

// [2]
public DiffUtilDataSetChanged(ItemsChecker<T> itemsChecker)

// [3]
public DiffUtilDataSetChanged(ItemsChecker<T> itemsChecker, boolean detectMoves)
```
 * **[0]** - is equvivalent of calling **[3]** with `new SimpleItemsChecker<>()` and `false`
 * **[1]** - is equvivalent of calling **[3]** with `new SimpleItemsChecker<>()` and `detectMoves`
 * **[2]** - is equvivalent of calling **[3]** with `itemsChecker` and `false`
 * **[3]** - constructor that accepts all possible configuration items

```java
public static abstract class ItemsChecker<T> {

    public abstract boolean areItemsTheSame(T oldItem, T newItem);
    public abstract boolean areContentsTheSame(T oldItem, T newItem);

    @Nullable
    public Object getChangePayload(T oldItem, T newItem) {
        return null;
    }
}
```

```java
public static class SimpleItemsChecker<T> extends ItemsChecker<T> {

    @Override
    public boolean areItemsTheSame(T oldItem, T newItem) {
        return oldItem == newItem;
    }

    @Override
    public boolean areContentsTheSame(T oldItem, T newItem) {
        return (oldItem == null && newItem == null)
                || (oldItem != null && newItem != null && oldItem.equals(newItem));
    }
}
```

### ru.noties.vt.OnItemClickListener
```java
public interface OnItemClickListener<T, H extends Holder> {
    void onItemClick(T item, H holder);
}
```

### ru.noties.vt.ViewTypes
Instance can be obtained via `ViewTypesAdapter.viewTypes()` method.
```java
// [0]
public boolean supportsDataSet(List objects)

// [1]
public boolean supports(Class<?> first, Class<?>... others)

// [2]
public int viewTypeCount()

// [3]
public ViewType viewType(@NonNull Object item) throws ViewTypesException

// [4]
public ViewType viewType(int assignedViewType) throws ViewTypesException

// [5]
public int assignedViewType(@NonNull Object item) throws ViewTypesException

// [6]
public int assignedViewType(@NonNull Class<?> cl) throws ViewTypesException
```
 * **[0]** - returns BOOLEAN showing that all items contain in the list have registered `ViewType`
 * **[1]** - returns BOOLEAN showing that all passed Classes have registered `ViewType`
 * **[2]** - returns total number of registered view types
 * **[3]** - returns `ViewType` associated with provided item. Throws `ViewTypesException` is no `ViewType` is registered for this item
 * **[4]** - returns `ViewType` associated with provided `assignedViewType` (returned by **[5]** or **[6]** method call). Throws `ViewTypesException` if no `ViewType` is associated with `assignedViewType`
 * **[5]** - equvivalent of calling **[6]** with `item.getClass()` as a parameter
 * **[6]** - returns assigned view type for this Class. Throws `ViewTypesException` if class has no associated view type


## License

```
  Copyright 2016 Dimitry Ivanov (mail@dimitryivanov.ru)

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
```
